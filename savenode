public class Rate {
    private Double interestRate;
    private Double annualYield;
    private Double minimumBalance;
    private Double maximumBalance;
    private Integer termsInMonths;
    private String tierName;
    private String effectiveDate;
    // Getters and setters
}

public class ProductMapping {
    private String subProductType;
    private List<Rate> rates;
    // Getters and setters
}

public class PartnerProductMapping {
    private String brand;
    private List<ProductMapping> productMappings;
    // Getters and setters
}

public class Data {
    private String productType;
    private List<PartnerProductMapping> partnerProductMappings;
    // Getters and setters
}

public class Meta {
    private String lastSyncTimestamp;
    private boolean isStale;
    private String correlationId;
    private Data data;
    // Getters and setters
}

@SlingServletPaths("/bin/store/json-to-jcr")
@Service(Servlet.class)
public class StoreJsonServlet extends SlingAllMethodsServlet {

    @Reference
    private ResourceResolverFactory resolverFactory;

    private static final Logger log = LoggerFactory.getLogger(StoreJsonServlet.class);

    @Override
    protected void doPost(SlingHttpServletRequest request, SlingHttpServletResponse response)
            throws ServletException, IOException {

        ObjectMapper mapper = new ObjectMapper();
        String trackingId = UUID.randomUUID().toString();

        try {
            // Parse only the "data" part
            JsonNode rootNode = mapper.readTree(request.getInputStream());
            JsonNode dataNode = rootNode.get("data");
            Data data = mapper.treeToValue(dataNode, Data.class);

            Map<String, Object> param = Map.of(ResourceResolverFactory.SUBSERVICE, "datawriter");

            try (ResourceResolver resolver = resolverFactory.getServiceResourceResolver(param)) {
                Session session = resolver.adaptTo(Session.class);
                Node baseNode = JcrUtil.createPath("/content/productdata", "nt:unstructured", session);

                Node dataJcrNode = JcrUtil.createPath(baseNode.getPath() + "/data", "nt:unstructured", session);
                dataJcrNode.setProperty("productType", data.getProductType());

                data.getPartnerProductMappings().stream().forEach(partner -> {
                    try {
                        Node partnerNode = dataJcrNode.addNode(partner.getBrand(), "nt:unstructured");

                        partner.getProductMappings().stream().forEach(productMapping -> {
                            try {
                                Node subProductNode = partnerNode.addNode(productMapping.getSubProductType(), "nt:unstructured");

                                AtomicInteger counter = new AtomicInteger(0);
                                productMapping.getRates().stream()
                                        .filter(Objects::nonNull)
                                        .forEach(rate -> {
                                            try {
                                                Node rateNode = subProductNode.addNode("rate" + counter.getAndIncrement(), "nt:unstructured");

                                                Optional.ofNullable(rate.getInterestRate()).ifPresent(val -> setProperty(rateNode, "interestRate", val));
                                                Optional.ofNullable(rate.getAnnualYield()).ifPresent(val -> setProperty(rateNode, "annualYield", val));
                                                Optional.ofNullable(rate.getMinimumBalance()).ifPresent(val -> setProperty(rateNode, "minimumBalance", val));
                                                Optional.ofNullable(rate.getMaximumBalance()).ifPresent(val -> setProperty(rateNode, "maximumBalance", val));
                                                Optional.ofNullable(rate.getTermsInMonths()).ifPresent(val -> setProperty(rateNode, "termsInMonths", val));
                                                Optional.ofNullable(rate.getTierName()).ifPresent(val -> setProperty(rateNode, "tierName", val));
                                                Optional.ofNullable(rate.getEffectiveDate()).ifPresent(val -> setProperty(rateNode, "effectiveDate", val));
                                            } catch (RepositoryException e) {
                                                log.error("Error creating rate node", e);
                                            }
                                        });

                            } catch (RepositoryException e) {
                                log.error("Error creating subProduct node", e);
                            }
                        });

                    } catch (RepositoryException e) {
                        log.error("Error creating partner node", e);
                    }
                });

                session.save();

                // Response JSON
                ObjectNode responseJson = mapper.createObjectNode();
                ObjectNode dataResponse = responseJson.putObject("data");
                dataResponse.put("status", "ACCEPTED");
                dataResponse.put("trackingId", trackingId);
                dataResponse.put("message", "success");

                response.setContentType("application/json");
                response.setStatus(HttpServletResponse.SC_OK);
                mapper.writeValue(response.getWriter(), responseJson);
            }

        } catch (Exception e) {
            log.error("Error storing data", e);
            response.setStatus(HttpServletResponse.SC_BAD_REQUEST);

            ObjectNode errorJson = mapper.createObjectNode();
            ObjectNode errorData = errorJson.putObject("data");
            errorData.put("status", "FAILED");
            errorData.put("trackingId", trackingId);
            errorData.put("message", e.getMessage());

            response.setContentType("application/json");
            mapper.writeValue(response.getWriter(), errorJson);
        }
    }

    private void setProperty(Node node, String name, Object value) {
        try {
            if (value instanceof Double) {
                node.setProperty(name, (Double) value);
            } else if (value instanceof Integer) {
                node.setProperty(name, (Integer) value);
            } else {
                node.setProperty(name, value.toString());
            }
        } catch (RepositoryException e) {
            log.error("Error setting property: " + name, e);
        }
    }
}


