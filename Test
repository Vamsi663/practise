import com.bcuspublic.wcm.service.deposits.FetchRatesService;
import com.bcuspublic.wcm.servlet.deposits.FetchRatesServlet;
import org.apache.sling.api.SlingHttpServletRequest;
import org.apache.sling.api.SlingHttpServletResponse;
import org.json.JSONArray;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;

import javax.servlet.ServletException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.IOException;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.*;

class FetchRatesServletTest {

    @InjectMocks
    private FetchRatesServlet servlet;

    @Mock
    private FetchRatesService fetchRatesService;

    @Mock
    private SlingHttpServletRequest request;

    @Mock
    private SlingHttpServletResponse response;

    private StringWriter responseWriter;

    @BeforeEach
    void setUp() throws Exception {
        MockitoAnnotations.openMocks(this);
        responseWriter = new StringWriter();
        when(response.getWriter()).thenReturn(new PrintWriter(responseWriter));
    }

    @Test
    void testDoGet_successfulResponse() throws ServletException, IOException {
        String[] selectors = {"deposits", "test-offer-instance-id"};
        when(request.getRequestPathInfo().getSelectors()).thenReturn(selectors);

        JSONArray mockRates = new JSONArray();
        JSONObject obj = new JSONObject();
        obj.put("interestRate", "4.0");
        mockRates.put(obj);

        when(fetchRatesService.getRates("test-offer-instance-id")).thenReturn(mockRates);

        servlet.doGet(request, response);

        verify(response).setContentType("application/json");
        assertTrue(responseWriter.toString().contains("interestRate"));
    }

    @Test
    void testDoGet_missingSelector() throws IOException {
        when(request.getRequestPathInfo().getSelectors()).thenReturn(new String[]{"deposits"});

        servlet.doGet(request, response);

        verify(response).setStatus(SlingHttpServletResponse.SC_BAD_REQUEST);
        assertTrue(responseWriter.toString().contains("No selectors specified"));
    }

    @Test
    void testDoGet_serviceException() throws Exception {
        String[] selectors = {"deposits", "bad-id"};
        when(request.getRequestPathInfo().getSelectors()).thenReturn(selectors);
        when(fetchRatesService.getRates("bad-id")).thenThrow(new RuntimeException("Service error"));

        servlet.doGet(request, response);

        verify(response).setStatus(SlingHttpServletResponse.SC_INTERNAL_SERVER_ERROR);
        assertTrue(responseWriter.toString().contains("Error while fetching rates"));
    }
}




@Test
public void testStoreRates_existingNodes() throws Exception {
    StoreRatesServiceImpl service = new StoreRatesServiceImpl();

    // Prepare input data
    StoreRatesRequest request = mockRequest();

    // Mock resource resolver and JCR structure
    ResourceResolvers resourceResolvers = Mockito.mock(ResourceResolvers.class);
    ResourceResolver resourceResolver = Mockito.mock(ResourceResolver.class);
    Session session = Mockito.mock(Session.class);
    Node offerInstancesNode = Mockito.mock(Node.class);
    Node offerInstanceNode = Mockito.mock(Node.class);
    Node ratesNode = Mockito.mock(Node.class);
    Node itemNode = Mockito.mock(Node.class);

    // Set up mocks to simulate existing nodes
    Mockito.when(resourceResolvers.getResourceResolver(SubService.WRITE_CONTENT)).thenReturn(resourceResolver);
    Mockito.when(resourceResolver.adaptTo(Session.class)).thenReturn(session);

    // Create path to return offerInstancesNode
    Mockito.mockStatic(JcrUtil.class).when(() ->
        JcrUtil.createPath(Mockito.anyString(), Mockito.anyString(), Mockito.eq(session))
    ).thenReturn(offerInstancesNode);

    // Simulate offer instance already exists
    Mockito.when(offerInstancesNode.hasNode("0dc29fc8-30c0-5e41-a503-c153a9dbbb69")).thenReturn(true);
    Mockito.when(offerInstancesNode.getNode("0dc29fc8-30c0-5e41-a503-c153a9dbbb69")).thenReturn(offerInstanceNode);

    // Simulate rates node exists
    Mockito.when(offerInstanceNode.hasNode("rates")).thenReturn(true);
    Mockito.when(offerInstanceNode.getNode("rates")).thenReturn(ratesNode);

    // Simulate item node exists
    Mockito.when(ratesNode.hasNode("item0")).thenReturn(true);
    Mockito.when(ratesNode.getNode("item0")).thenReturn(itemNode);

    // Execute
    service.storeRates(request, resourceResolvers);

    // Verify path
    Mockito.verify(itemNode, Mockito.atLeastOnce()).setProperty(Mockito.anyString(), Mockito.any());
    Mockito.verify(session).save();
}


import com.bcuspublic.wcm.constants.DepositConstants;
import com.bcuspublic.wcm.service.deposits.FetchRatesServiceImpl;
import com.bcuspublic.wcm.service.common.ResourceResolvers;
import org.apache.sling.api.resource.*;
import org.json.JSONArray;
import org.json.JSONObject;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;

import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class FetchRatesServiceImplTest {

    @InjectMocks
    private FetchRatesServiceImpl fetchRatesService;

    @Mock
    private ResourceResolvers resourceResolvers;

    @Mock
    private ResourceResolver resourceResolver;

    @Mock
    private Resource ratesResource;

    @Mock
    private Resource childResource;

    @Mock
    private ValueMap valueMap;

    @BeforeEach
    void setUp() throws LoginException {
        MockitoAnnotations.openMocks(this);
        when(resourceResolvers.getResourceResolver(ResourceResolvers.SubService.READ_CONTENT))
            .thenReturn(resourceResolver);
    }

    @Test
    void testGetRates_returnsValidRatesArray() {
        String offerInstanceId = "test-offer-id";
        String expectedPath = DepositConstants.RATES_STORE_PATH + "/" +
                              DepositConstants.OFFER_INSTANCES + "/" +
                              offerInstanceId + "/" +
                              DepositConstants.RATES;

        when(resourceResolver.getResource(expectedPath)).thenReturn(ratesResource);
        when(ratesResource.getChildren()).thenReturn(Collections.singleton(childResource));
        when(childResource.getValueMap()).thenReturn(valueMap);

        Map<String, Object> properties = new HashMap<>();
        properties.put("interestRate", "4.5");
        properties.put("annualYield", "4.4");

        when(valueMap.entrySet()).thenReturn(properties.entrySet());

        JSONArray result = fetchRatesService.getRates(offerInstanceId);

        assertEquals(1, result.length());
        JSONObject obj = result.getJSONObject(0);
        assertEquals("4.5", obj.get("interestRate"));
        assertEquals("4.4", obj.get("annualYield"));
    }

    @Test
    void testGetRates_returnsEmptyArray_whenResourceIsNull() {
        when(resourceResolver.getResource(anyString())).thenReturn(null);
        JSONArray result = fetchRatesService.getRates("non-existent-id");
        assertEquals(0, result.length());
    }

    @Test
    void testGetRates_handlesException() throws LoginException {
        when(resourceResolvers.getResourceResolver(any())).thenThrow(new RuntimeException("test failure"));
        JSONArray result = fetchRatesService.getRates("id-causing-error");
        assertEquals(0, result.length());
    }
}


@ExtendWith(MockitoExtension.class)
public class FetchRatesServiceTest {

    @InjectMocks
    private FetchRatesService fetchRatesService;

    @Mock
    private ResourceResolver resourceResolver;

    @Mock
    private Resource ratesResource;

    @Mock
    private Resource childResource;

    @Mock
    private ValueMap valueMap;

    @BeforeEach
    void setup() {
        // No-op if using @ExtendWith + @Mock
    }

    @Test
    public void testGetRates_returnsValidRatesArray() throws Exception {
        String offerInstanceId = "test-offer-id";
        String expectedPath = "/content/bcuspublic/data/deposits/offerinstances/" + offerInstanceId + "/rates";

        // Mock resource resolution
        when(resourceResolver.getResource(expectedPath)).thenReturn(ratesResource);

        // Mock child iteration
        Iterator<Resource> iterator = Mockito.mock(Iterator.class);
        when(ratesResource.getChildren()).thenReturn(() -> iterator); // Iterable lambda

        when(iterator.hasNext()).thenReturn(true, false);
        when(iterator.next()).thenReturn(childResource);

        // Mock value map
        Map<String, Object> props = new HashMap<>();
        props.put("interestRate", "4.5");
        props.put("annualYield", "4.4");

        when(childResource.getValueMap()).thenReturn(new ValueMapDecorator(props));

        // Execute
        JSONArray result = fetchRatesService.getRates(offerInstanceId, resourceResolver);

        // Assert
        Assert.assertEquals(1, result.length());
        JSONObject obj = result.getJSONObject(0);
        Assert.assertEquals("4.5", obj.get("interestRate"));
        Assert.assertEquals("4.4", obj.get("annualYield"));
    }

    @Test
    public void testGetRates_returnsEmptyArray_whenResourceIsNull() throws Exception {
        String offerInstanceId = "non-existent-id";
        when(resourceResolver.getResource(anyString())).thenReturn(null);

        JSONArray result = fetchRatesService.getRates(offerInstanceId, resourceResolver);

        Assert.assertEquals(0, result.length());
    }
}

    @Mock
    private ResourceResolvers resourceResolvers;

    @Mock
    private ResourceResolver resourceResolver;

    @Mock
    private Resource ratesResource;

    @Mock
    private Resource childResource;

    private FetchRatesServiceImpl fetchRatesService;

    @Before
    public void setup() throws Exception {
        MockitoAnnotations.initMocks(this);
        fetchRatesService = new FetchRatesServiceImpl();
        when(resourceResolvers.getResourceResolver(SubService.READ_CONTENT)).thenReturn(resourceResolver);
    }

    @Test
    public void testGetRates_returnsValidRatesArray() throws Exception {
        String offerInstanceId = "test-offer-id";
        String expectedPath = "/content/bcuspublic/data/deposits/offerinstances/" + offerInstanceId + "/rates";

        // Mock getResource
        when(resourceResolver.getResource(expectedPath)).thenReturn(ratesResource);

        // Mock getChildren
        Iterable<Resource> children = Collections.singletonList(childResource);
        when(ratesResource.getChildren()).thenReturn(children);

        // Mock ValueMap
        Map<String, Object> properties = new HashMap<>();
        properties.put("interestRate", "4.5");
        properties.put("annualYield", "4.4");
        ValueMap valueMap = new ModifiableValueMapDecorator(properties);
        when(childResource.getValueMap()).thenReturn(valueMap);

        JSONArray result = fetchRatesService.getRates(offerInstanceId, resourceResolver);

        assertEquals(1, result.length());
        JSONObject obj = result.getJSONObject(0);
        assertEquals("4.5", obj.get("interestRate"));
        assertEquals("4.4", obj.get("annualYield"));
    }

    @Test
    public void testGetRates_returnsEmptyArray_whenResourceIsNull() throws Exception {
        when(resourceResolver.getResource(anyString())).thenReturn(null);

        JSONArray result = fetchRatesService.getRates("non-existent-id", resourceResolver);

        assertEquals(0, result.length());
    }




@Test
public void test_storeRates_save() throws Exception {
    // Arrange
    StoreRatesRequest request = mockRequest();
    request.getData().getProductRates().get(0).setOfferInstanceId("new-offer-instance-id");
    request.getData().getProductRates().get(0).setProductName("Dummy product");

    Rates rates = new Rates();
    rates.set("dummyKey", "dummyValue");
    request.getData().getProductRates().get(0).setRates(Collections.singletonList(rates));

    StoreRatesServiceImpl storeRatesService = new StoreRatesServiceImpl();

    Session mockSession = Mockito.mock(Session.class);
    Node mockRootNode = Mockito.mock(Node.class);
    Node mockOfferInstanceNode = Mockito.mock(Node.class);
    Node mockRatesNode = Mockito.mock(Node.class);
    Node mockItemNode = Mockito.mock(Node.class);

    // Mock session -> root node
    Mockito.when(mockSession.getRootNode()).thenReturn(mockRootNode);

    // Mock root node -> offerInstances -> offerInstanceNode
    Mockito.when(mockRootNode.hasNode("content/bcuspublic/data/deposits/offerinstances"))
           .thenReturn(true);
    Mockito.when(mockRootNode.getNode("content/bcuspublic/data/deposits/offerinstances"))
           .thenReturn(mockOfferInstanceNode);

    Mockito.when(mockOfferInstanceNode.hasNode("new-offer-instance-id"))
           .thenReturn(false);
    Mockito.when(mockOfferInstanceNode.addNode("new-offer-instance-id"))
           .thenReturn(mockOfferInstanceNode);

    Mockito.when(mockOfferInstanceNode.hasNode("rates"))
           .thenReturn(false);
    Mockito.when(mockOfferInstanceNode.addNode("rates"))
           .thenReturn(mockRatesNode);

    Mockito.when(mockRatesNode.addNode("item0")).thenReturn(mockItemNode);

    // Make session.save() throw exception
    Mockito.doThrow(new RepositoryException("Simulated RepositoryException"))
           .when(mockSession).save();

    // Mock resource resolver + session
    Mockito.when(resourceResolvers.getResourceResolver(SubService.WRITE_CONTENT))
           .thenReturn(resourceResolver);
    Mockito.when(resourceResolver.adaptTo(Session.class))
           .thenReturn(mockSession);

    // Act
    storeRatesService.storeRates(request, resourceResolvers);

    // Assert
    // No need to assert, this test is only to reach RepositoryException branch
}

















