// === ADD: drive buildTreeViewForSecondaryOffers branches ===
final String ASSOC = "SECONDARY_INC_ASSOCIATE"; // must be this to hit the method

// Avoid child traversal so we don't wander into logging/json
Mockito.when(page.listChildren(Mockito.any(com.day.cq.wcm.api.PageFilter.class)))
       .thenReturn(null);

// ---------- IF branch: multiple values -> loop runs once ----------
Mockito.when(pageContentNode.hasProperty(OFFERIDS)).thenReturn(true);
Mockito.when(pageContentNode.getProperty(OFFERIDS)).thenReturn(property);
Mockito.when(property.isMultiple()).thenReturn(true);
Value v = Mockito.mock(Value.class);
Mockito.when(v.getString()).thenReturn("id1");
Mockito.when(property.getValues()).thenReturn(new Value[]{ v });

// resolver is called twice per invocation (Page, then /jcr:content Node)
Mockito.when(resourceResolver.getResource(Mockito.anyString()))
       .thenReturn(pageRes, contentRes);

try {
    associateOfferToPageSupport.fetchLandingPagesWithOfferIds(
        resourceResolver, secondaryOfferIds, ASSOC);
} catch (NullPointerException ignored) {
    // expected if deeper OfferUtils/logging touches un-mocked data;
    // lines after 168 are covered before this point
}

// ---------- ELSE path inside IF: single value (prop.isMultiple == false) ----------
Mockito.when(resourceResolver.getResource(Mockito.anyString()))
       .thenReturn(pageRes, contentRes);
Mockito.when(pageContentNode.hasProperty(OFFERIDS)).thenReturn(true);
Mockito.when(pageContentNode.getProperty(OFFERIDS)).thenReturn(property);
Mockito.when(property.isMultiple()).thenReturn(false);
Value single = Mockito.mock(Value.class);
Mockito.when(single.toString()).thenReturn("id1"); // code calls getValue().toString()
Mockito.when(property.getValue()).thenReturn(single);

try {
    associateOfferToPageSupport.fetchLandingPagesWithOfferIds(
        resourceResolver, secondaryOfferIds, ASSOC);
} catch (NullPointerException ignored) {
    // same note as above
}
// === END ADD ===
